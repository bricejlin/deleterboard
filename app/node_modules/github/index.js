var request = require('superagent');
var Promise = require('bluebird');
var groupBy = require('lodash.groupby');

var OAUTH = '?client_id=1ce45fb91c0fd87d9c9c&client_secret=514aeb20a5c9a33987d0a4daf2adf9d4f3dbd885';

var GITHUB_API = 'https://ghe.spotify.net/api/v3'; //'https://api.github.com/';
var OWNER = 'ads';

function github () {  
  function getStats () {
    return fetchRepos()
      .then(getRepoNames)
      .then(fetchCommitsFromEachRepo)
      .then(flatten)
      .then(filterByDate)
      .then(fetchStatsFromEachCommit)
      .then(groupByName)
      .then(sortByStats);
  }

  function sortByStats (users) {
    return users.sort(function (a, b) {
      if (a.stats.delta < b.stats.delta) {
        return 1;
      }
      if (a.stats.delta > b.stats.delta) {
        return -1;
      }
      return 0;
    });
  }

  function fetchRepos () {
    var deferred = Promise.defer();
    console.log('fetching repos...');

    request
      .get(GITHUB_API + '/orgs/' + OWNER + '/repos' + OAUTH)
      .timeout(7000)
      .on('error', function (err) { console.error(err); })
      .end(function (err, res) {
        if (err) {
          deferred.reject(res);
        } else {
          deferred.resolve(res.body);
        }
      });

    return deferred.promise;
  }

  function getRepoNames (repos) {
    return repos.map(function (repo) {
      return repo.name;
    });
  }

  function fetchCommitsFromEachRepo (repos) {
    console.log('fetching commits from each repo...');
    var promises = repos.map(function (repo) {
      return fetchCommits(repo);
    });

    return Promise.all(promises);
  }

  function fetchCommits (repo) {
    var deferred = Promise.defer();
    var url = GITHUB_API + '/repos/' + OWNER + '/' + repo + '/commits' + OAUTH;
    request
      .get(url)
      .timeout(7000)
      .on('error', function (err) { console.error(err); })
      .end(function (err, res) {
        if (err) deferred.reject(res);
        deferred.resolve(res.body);
      });
    return deferred.promise;
  }

  function flatten (arr) {
    console.log('flattening commits...');
    return arr.reduce(function (a, b) {
      return a.concat(b);
    });
  }

  function filterByDate (commits) {
    var date = new Date('4-1-15');

    console.log('filtering for commits after ' + date.toLocaleDateString() + '...');

    return commits.filter(function (commit) {
      var commitDate = new Date(commit.commit.author.date);
      return getUTCDateString(commitDate) >= getUTCDateString(date);
    });
  }

  function fetchStatsFromEachCommit (commits) {
    console.log('fetching commit stats...');
    var promises = commits.map(function (commit) {
      return fetchCommitStats(commit.url)
        .then(function (res) {
          return {
            name: res.commit.author.name,
            stats: res.stats
          };
        });
    });
    return Promise.all(promises);
  }

  function fetchCommitStats (url) {
    var deferred = Promise.defer();
    request
      .get(url + OAUTH)
      .timeout(15000)
      .on('error', function (err) { console.error(err); })
      .end(function (err, res) {
        if (err) deferred.reject(res);
        deferred.resolve(res.body);
      });
    return deferred.promise;
  }

  function groupByName (commits) {
    var namesObj = groupBy(commits, function (commit) {
      return commit.name;
    });

    var people = [];

    for (var name in namesObj) {
      people.push({
        name: name,
        stats: formatStats(namesObj[name])
      });
    }

    return people;
  }

  function formatStats (stats) {
    var obj = { additions: 0, deletions: 0, delta: 0 };
    return stats.reduce(function (p, c) {
      p.additions += c.stats.additions;
      p.deletions += c.stats.deletions;
      p.delta += c.stats.deletions - c.stats.additions;
      return p;
    }, obj);
  }

  function getUTCDateString (date) {
    return date.getUTCFullYear() + '-' + date.getUTCDate() + '-' + date.getUTCMonth();
  }

  return {
    getStats: getStats
  };
}

module.exports = github();